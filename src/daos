function finalizeFundraising(int24 initialTick, int24 upperTick) external {
        require(goalReached, "Fundraising goal not reached");
        require(!fundraisingFinalized, "DAO tokens already minted");
        require(daoToken != address(0), "Token not set");
        require(secondToken != address(0), "secondToken not set");


        emit DebugLog("Starting finalizeFundraising");
        DaosWorldV1Token token = DaosWorldV1Token(daoToken);

        // Mint tokens to contributors
        for (uint256 i = 0; i < contributors.length; i++) {
            address contributor = contributors[i];
            uint256 tokensToMint = (contributions[contributor] *
                SUPPLY_TO_FUNDRAISERS) / totalRaised;

            emit MintDetails(contributor, tokensToMint);
            token.mint(contributor, tokensToMint);
        }

        emit FundraisingFinalized(true);
        fundraisingFinalized = true;

        //Determine Order

        if (daoToken < secondToken) {
            token0 = daoToken;
            token1 = secondToken;
        } else {
            token0 = secondToken;
            token1 = daoToken;
        }

        // Create pool directly through factory
        address poolAddress = ICLFactory(0x04625B046C69577EfC40e6c0Bb83CDBAfab5a55F)
            .createPool(
                token0,
                token1,
                TICKING_SPACE,
                TickMath.getSqrtRatioAtTick(initialTick)
            );
        emit PoolCreated(poolAddress);

        uint256 amountToken0ForLP = 10_000 ether; // "bigger" example
        uint256 amountToken1ForLP = 10_000 ether; // "bigger" example

        if (token0 == address(token)) {
            // If token0 is the DAO token we control
            token.mint(address(this), amountToken0ForLP);
        } else {
            // If you have a custom ERC20 secondToken, you'd handle it similarly
            // Example:
            DaosWorldV1Token(secondToken).mint(address(this), amountToken0ForLP);
        }

        if (token1 == address(token)) {
            // If token1 is the DAO token
            token.mint(address(this), amountToken1ForLP);
        } else {
            // If secondToken is token1
            DaosWorldV1Token(secondToken).mint(address(this), amountToken1ForLP);
        }

         token.renounceOwnership();
          IERC20(token0).approve(poolAddress, amountToken0ForLP);
        IERC20(token1).approve(poolAddress, amountToken1ForLP);

        TickMath.getSqrtRatioAtTick(initialTick) // or the current pool price

        uint128 liquidity = calculateLiquidity(
            amountToken0ForLP,
            amountToken1ForLP,
            initialTick,
            upperTick,
            TickMath.getSqrtRatioAtTick(initialTick) // or the current pool price
        );

        // Add liquidity directly to pool
        ICLPool(poolAddress).mint(
            address(this),
            initialTick,
            upperTick,
           liquidity,
            ""
        );
         emit DebugLog("Liquidity minted to new pool");
    }

    function uniswapV3MintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata data) external {
        if (amount0Owed > 0) {
            IERC20(token0).transfer(msg.sender, amount0Owed);
        }
        if (amount1Owed > 0) {
            IERC20(token1).transfer(msg.sender, amount1Owed);
        }
    }


    function calculateLiquidity(
        uint256 amount0,          // how many units of token0 we can supply
        uint256 amount1,          // how many units of token1 we can supply
        int24 tickLower,
        int24 tickUpper,
        uint160 currentSqrtPrice
    ) public pure returns (uint128) {
         uint256 naiveMin = (amount0 < amount1) ? amount0 : amount1;
        return uint128(naiveMin);
    }